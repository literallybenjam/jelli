// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";

  /*
  THE JELLI GAME ENGINE
  Programmed by Margaret Russel
  -----------------------------
  Implemented through several modules in Literate CoffeeScript.
  Source code and resources are available at https://github.com/literallybenjam/jelli/.
   */

  /*
  MIT License
  
  Copyright (c) 2016 Margaret Russel
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
   */

  /*
  How To Use:
  
  The `Game` constructor creates a new game, which is automatically assigned to `document.game`.
  You can choose a different document for game rendering by passing it in as an attribute.
  A document can have only one game assigned to it at a time, and this game is non-configurable.
  
  A sample loading script might look like this:
  
      window.addEventListener("load", function () {new Game(document);}, false);
   */


}).call(this);
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";

  /*
  KEYBOARD
  Keyboard input tracking
  ---------------------
   */
  var Keyboard,
    slice = [].slice;

  Keyboard = function(doc) {
    if (doc == null) {
      doc = document;
    }
    this.codes = {};
    this.keys = {};
    this.ownerDocument = !(doc instanceof Document) ? document : doc;
    Object.freeze(this);
    doc.defaultView.addEventListener("keydown", this, false);
    return doc.defaultView.addEventListener("keyup", this, false);
  };

  Keyboard.prototype = {
    add: function(name) {
      if (name != null) {
        this.controls[name] = false;
      }
      return this;
    },
    addCodes: function() {
      var code, codes, i, len, name;
      name = arguments[0], codes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!((name != null) && (this.keys[name] != null))) {
        for (i = 0, len = codes.length; i < len; i++) {
          code = codes[i];
          this.codes[code] = name;
        }
      }
      return this;
    },
    getName: function(code) {
      if ((code != null) && (this.codes[code] != null)) {
        return this.codes[code];
      }
    },
    handleEvent: function(e) {
      var code, i, j, len, len1, ref, ref1;
      if (!(e instanceof Event)) {
        return;
      }
      switch (e.type) {
        case "keydown":
          ref = [e.code, e.key, e.keyIdentifier, e.keyCode];
          for (i = 0, len = ref.length; i < len; i++) {
            code = ref[i];
            if (this.isCodeDefined(code)) {
              this.toggleCode(code, true);
            }
          }
          break;
        case "keyup":
          ref1 = [e.code, e.key, e.keyIdentifier, e.keyCode];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            code = ref1[j];
            if (this.isCodeDefined(code)) {
              this.toggleCode(code, false);
            }
          }
      }
    },
    isActive: function(name) {
      if ((name != null) && (this.keys[name] != null)) {
        return !!this.keys[name];
      }
    },
    isDefined: function(name) {
      if (name != null) {
        return this.keys[name] != null;
      }
    },
    isCodeActive: function(code) {
      var name;
      if ((code != null) && ((name = this.codes[code]) != null) && (this.keys[name] != null)) {
        return !!this.keys[name];
      }
    },
    isCodeDefined: function(code) {
      var name;
      if ((code != null) && ((name = this.codes[code]) != null)) {
        return this.keys[name] != null;
      }
    },
    remove: function(name) {
      if (name != null) {
        delete this.keys[name];
      }
      return this;
    },
    removeCodes: function() {
      var code, codes, i, len;
      codes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (i = 0, len = codes.length; i < len; i++) {
        code = codes[i];
        delete this.codes[code];
      }
      return this;
    },
    toggle: function(name, to) {
      if ((name != null) && (this.keys[name] != null)) {
        return this.keys[name] = (to != null) && to || (to == null) && !this.keys[name];
      }
    },
    toggleCode: function(code, to) {
      var name;
      if ((code != null) && (name = this.codes[code]) && (this.keys[name] != null)) {
        return controls[name] = (to != null) && to || (to == null) && !this.keys[name];
      }
    }
  };

  Object.freeze(Keyboard.prototype);

  window.Keyboard = Object.freeze(Keyboard);

}).call(this);
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";

  /*
  LETTERS
  Sprite-based text processing and rendering
  ------------------------------------------
   */
  var Letter, LetterBlock, LetterString, Letters,
    slice = [].slice;

  drawLetter(function(letters, index, context, x, y) {
    var height, i, j, width;
    if (!(letters instanceof Letters && index < letters.size && context instanceof CanvasRenderingContext2D)) {
      return;
    }
    if (isNaN(index = Number(index))) {
      index = 0;
    }
    if (isNaN(x = Math.round(x))) {
      x = 0;
    }
    if (isNaN(y = Math.round(y))) {
      y = 0;
    }
    i = index % letters.width;
    j = Math.floor(index / letters.width);
    if (letters.canvas instanceof HTMLCanvasElement && !isNaN(i) && !isNaN(j) && (width = Number(letters.letter_width)) && (height = Number(letters.letter_height))) {
      return context.drawImage(letters.canvas, i * width, j * height, width, height, x, y, width, height);
    }
  });

  Letter = function(letters, index) {
    if (!(letters instanceof Letters)) {
      letters = null;
    }
    if (isNaN(index = Number(index))) {
      index = 0;
    }
    this.canvas = letters ? letters.canvas : null;
    this.draw = drawLetter.bind(this, letters, index);
    this.height = letters ? letters.letter_height : 0;
    this.index = index;
    this.letters = letters;
    this.width = letters ? letters.letter_width : 0;
    return Object.freeze(this);
  };

  Letter.prototype = {
    draw: function() {}
  };

  Object.freeze(Letter.prototype);

  LetterBlock = function() {
    var context, index, k, len, letters, multiGetter, multiSetter, string, strings, x, y;
    letters = arguments[0], context = arguments[1], x = arguments[2], y = arguments[3], strings = 5 <= arguments.length ? slice.call(arguments, 4) : [];
    if (!(context instanceof CanvasRenderingContext2D)) {
      context = null;
    }
    if (!(letters instanceof Letters)) {
      letters = null;
    }
    if (isNaN(x = Math.round(x))) {
      x = 0;
    }
    if (isNaN(y = Math.round(y))) {
      y = 0;
    }
    for (index = k = 0, len = strings.length; k < len; index = ++k) {
      string = strings[index];
      this[index] = (string instanceof LetterString ? string : new LetterString(letters, string));
    }
    Object.defineProperties(this, {
      context: {
        value: context
      },
      height: {
        value: strings.length
      },
      letters: {
        value: letters
      }
    });
    multiGetter = function(prop) {
      var i, n;
      i = 0;
      n = 0;
      while (i++ < this.height && this[i][prop] === this[i].length) {
        n += this[i].length;
      }
      if (i < this.height) {
        return n + this[i][prop];
      } else {
        return n;
      }
    };
    multiSetter = function(prop, n) {
      var i, results;
      i = 0;
      if (isNaN(n = Number(n))) {
        n = 0;
      }
      while (i++ < this.height && n > this[i].length) {
        n -= this[i][prop] = this[i].length;
      }
      if (i < this.height) {
        this[i][prop] = n;
      }
      results = [];
      while (++i < this.height) {
        results.push(this[i][prop] = 0);
      }
      return results;
    };
    Object.defineProperties(this, {
      delIndex: {
        get: multiGetter.bind(this, "delIndex"),
        set: multiSetter.bind(this, "delIndex")
      },
      drawIndex: {
        get: multiGetter.bind(this, "drawIndex"),
        set: multiSetter.bind(this, "drawIndex")
      },
      index: {
        get: multiGetter.bind(this, "index"),
        set: multiSetter.bind(this, "index")
      }
    });
    Object.defineProperty(this, "length", {
      get: function() {
        var i, n;
        i = 0;
        n = 0;
        while (i++ < this.height) {
          n += this[i].length;
        }
        return n;
      }
    });
    Object.defineProperties(this, {
      x: {
        get: function() {
          return x;
        },
        set: function(n) {
          if (!isNaN(n)) {
            x = Number(n);
            this.delIndex = 0;
            return this.drawIndex = 0;
          }
        }
      },
      y: {
        get: function() {
          return y;
        },
        set: function(n) {
          if (!isNaN(n)) {
            y = Number(n);
            this.delIndex = 0;
            return this.drawIndex = 0;
          }
        }
      }
    });
    return Object.freeze(this);
  };

  LetterBlock.prototype = Object.create(LetterString.prototype, {
    draw: {
      value: function() {
        var index, iy, line;
        iy = this.y;
        for (index in this) {
          line = this[index];
          if (line instanceof LetterString) {
            line.draw(this.context, this.x, iy);
          }
          iy += this.letters.letter_height + 1;
        }
      }
    },
    item: {
      value: function(n) {
        var i;
        i = 0;
        if (isNaN(n = Number(n))) {
          return null;
        }
        while ((this[i++] != null) && n > this[i].length) {
          n -= this[i].length;
        }
        if (this[i] != null) {
          return this[i].item(n);
        } else {
          return null;
        }
      }
    },
    line: {
      value: function(n) {
        if (this[n] instanceof LetterString) {
          return this[n];
        } else {
          return null;
        }
      }
    }
  });

  Object.freeze(LetterBlock.prototype);

  LetterString = function(letters, data) {
    var delIndex, drawIndex, index, k, len, letter;
    if (!(letters instanceof Letters)) {
      letters = null;
    }
    data = String(data);
    delIndex = 0;
    drawIndex = 0;
    drawIndex = 0;
    Object.defineProperties(this, {
      delIndex: {
        get: function() {
          return delIndex;
        },
        set: function(n) {
          if (!isNaN(n = Math.round(n))) {
            return delIndex = n;
          }
        }
      },
      drawIndex: {
        get: function() {
          return drawIndex;
        },
        set: function(n) {
          if (!isNaN(n = Math.round(n))) {
            return drawIndex = n;
          }
        }
      },
      index: {
        get: function() {
          return index;
        },
        set: function(n) {
          var index;
          if (!isNaN(n = Math.round(n))) {
            return index = n;
          }
        }
      }
    });
    Object.defineProperties(this, {
      data: {
        value: data
      },
      length: {
        value: data.length
      },
      letters: {
        value: letters
      }
    });
    for (index = k = 0, len = data.length; k < len; index = ++k) {
      letter = data[index];
      this[index] = letters != null ? letters.item(data.charCodeAt(i)) : void 0;
    }
    return Object.freeze(this);
  };

  LetterString.prototype = {
    advance: function(amount) {
      var i;
      if (amount == null) {
        amount = 1;
      }
      i = this.index;
      i += isNaN(amount = Math.round(amount)) ? 1 : amount;
      if (i < 0) {
        i = 0;
      }
      if (i > this.length) {
        i = this.length;
      }
      this.index = i;
      if (this.delIndex > i) {
        this.delIndex = i;
      }
      return i;
    },
    clear: function() {
      return this.index = this.delIndex = 0;
    },
    draw: function(context, x, y) {
      var height, width;
      if (!(context instanceof CanvasRenderingContext2D && this.letters instanceof Letters && (width = Number(this.letters.letter_width)) && (height = Number(this.letters_letter_height)))) {
        return;
      }
      if (isNaN(x = Math.round(x))) {
        x = 0;
      }
      if (isNaN(y = Math.round(y))) {
        y = 0;
      }
      if (this.drawIndex > this.length) {
        this.drawIndex = this.length;
      }
      if (this.drawIndex < 0) {
        this.drawIndex = 0;
      }
      if (this.delIndex > this.index) {
        this.delIndex = this.index;
      }
      if (this.delIndex < 0) {
        this.delIndex = 0;
      }
      if (this.drawIndex > this.delIndex) {
        context.clearRect(x + this.delIndex * (width + 1), y, (this.drawIndex - this.delIndex) * (width + 1), height + 1);
        this.drawIndex = this.delIndex;
      }
      while (this.drawIndex < this.length && this.drawIndex < this.index) {
        if (!(this[this.drawIndex] instanceof Letter)) {
          continue;
        }
        this[this.drawIndex].draw(context, x + this.drawIndex * (width + 1), y);
        this.drawIndex++;
      }
      return this.delIndex = this.drawIndex;
    },
    fill: function() {
      return this.index = this.length;
    },
    item: function(n) {
      if (this[n] instanceof Letter) {
        return this[n];
      } else {
        return null;
      }
    }
  };

  Object.freeze(LetterString.prototype);

  Letters = function(source, letter_width, letter_height, doc) {
    var canvas, color, context, index, memory, source_height, source_width;
    if (doc == null) {
      doc = document;
    }
    if (!(source instanceof HTMLImageElement || source instanceof SVGImageElement || source instanceof HTMLCanvasElement || (typeof createImageBitmap !== "undefined" && createImageBitmap !== null) && source instanceof ImageBitmap)) {
      source = void 0;
    }
    if (isNaN(letter_width = Number(letter_width))) {
      letter_width = 0;
    }
    if (isNaN(letter_height = Number(letter_height))) {
      letter_height = 0;
    }
    if (!(doc instanceof Document)) {
      doc = document;
    }
    if (source instanceof Element && source.ownerDocument !== doc) {
      source = doc.importNode(source, true);
    }
    if (!((source != null) && !isNaN(source_width = Number(source.naturalWidth != null ? source.naturalWidth : source.width)))) {
      source_width = 0;
    }
    if (!((source != null) && !isNaN(source_height = Number(source.naturalHeight != null ? source.naturalHeight : source.height)))) {
      source_height = 0;
    }
    if (source != null) {
      canvas = doc.createElement("canvas");
      canvas.width = source_width;
      canvas.height = source_height;
      context = canvas.getContext("2d");
      if (!(source instanceof HTMLImageElement && !source.complete)) {
        context.drawImage(source, 0, 0);
      }
    } else {
      canvas = context = null;
    }
    Object.defineProperties(this, {
      canvas: {
        value: canvas
      },
      context: {
        value: context
      },
      height: {
        value: Math.floor(source_height / letter_height)
      },
      letter_height: {
        value: letter_height
      },
      letter_width: {
        value: letter_width
      },
      size: {
        value: Math.floor(source_height / letter_height) * Math.floor(source_width / letter_width)
      },
      source: {
        value: source
      },
      width: {
        value: Math.floor(source_width / letter_width)
      }
    });
    color = Letters.NO_COLOR;
    Object.defineProperty(this, "color", {
      get: function() {
        return color;
      },
      set: function(n) {
        if (n === Letters.NO_COLOR) {
          color = n;
          if (this.context instanceof CanvasRenderingContext2D) {
            this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
            if (!(this.source instanceof HTMLImageElement && !this.source.complete)) {
              return this.context.drawImage(this.source, 0, 0);
            }
          }
        } else {
          color = String(n);
          if (this.context instanceof CanvasRenderingContext2D) {
            this.context.globalCompositeOperation = "source-in";
            this.context.context.fillStyle = color;
            this.context.fillRect(0, 0, this.context.canvas.width, this.context.canvas.height);
            return this.context.globalCompositeOperation = "source-over";
          }
        }
      }
    });
    index = this.size;
    memory = [];
    ({
      getIndex: function(i) {
        if (memory[i] != null) {
          return memory[i];
        } else {
          return memory[i] = new Letter(this, i);
        }
      }
    });
    while (index-- > 0) {
      Object.defineProperty(this, index, {
        get: getIndex.bind(this, index)
      });
    }
    return Object.freeze(this);
  };

  Letters.prototype = {
    clearColor: function() {
      return this.color = Letters.NO_COLOR;
    },
    createBlock: function() {
      var context, data, x, y;
      context = arguments[0], x = arguments[1], y = arguments[2], data = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      return new (LetterBlock.bind.apply(LetterBlock, [null, this, context, x, y].concat(slice.call(data))))();
    },
    createString: function(data) {
      return new LetterString(this, data);
    },
    item: function(i) {
      if (this[i] instanceof Letter) {
        return this[i];
      } else {
        return null;
      }
    }
  };

  Object.freeze(this);

  Object.defineProperty(Letters, "NO_COLOR", {
    value: typeof Symbol !== "undefined" && Symbol !== null ? Symbol("none") : Object.freeze(Object.create(null))
  });

  Letters.Block = Object.freeze(LetterBlock);

  Letters.Letter = Object.freeze(Letter);

  Letters.String = Object.freeze(LetterString);

  window.Letters = Object.freeze(Letters);

}).call(this);
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";

  /*
  SCREEN
  Convenient canvas and context packaging
  ---------------------------------------
   */
  var Screen;

  Screen = function(canvas, context) {
    var doc;
    if (context == null) {
      context = "2d";
    }
    if (!(canvas instanceof HTMLCanvasElement)) {
      doc = document;
      canvas = doc.getElementById(canvas);
      if (!(canvas instanceof HTMLCanvasElement)) {
        canvas = void 0;
      }
    } else {
      doc = canvas.ownerDocument;
    }
    this.canvas = canvas;
    if (canvas) {
      this.context = canvas.getContext(context);
    }
    this.ownerDocument = doc;
    Object.defineProperties(this, {
      height: {
        get: function() {
          if (this.canvas) {
            return this.canvas.height;
          }
        },
        set: function(n) {
          if (this.canvas) {
            return this.canvas.height = n;
          }
        },
        enumerated: true
      },
      width: {
        get: function() {
          if (this.canvas) {
            return this.canvas.width;
          }
        },
        set: function(n) {
          if (this.canvas) {
            return this.canvas.width = n;
          }
        },
        enumerated: true
      }
    });
    return Object.freeze(this);
  };

  Screen.prototype = {
    clear: function() {
      if (!(this.canvas instanceof HTMLCanvasElement)) {
        return;
      }
      switch (false) {
        case !(this.context instanceof CanvasRenderingContext2D):
          return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        case !(this.context instanceof WebGLRenderingContext):
          return this.context.clear(this.context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
      }
    }
  };

  Object.freeze(Screen.prototype);

  window.Screen = Object.freeze(Screen);

}).call(this);
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";

  /*
  SHEET
  Sprite-sheet managing
  ---------------------
   */
  var Sheet, Sprite, drawSprite;

  drawSprite = function(sheet, start_index, context, x, y, frame) {
    var height, i, image, j, source, width;
    if (frame == null) {
      frame = 1;
    }
    if (!(sheet instanceof Sheet && start_index < sheet.size && context instanceof CanvasRenderingContext2D)) {
      return;
    }
    if (isNaN(start_index = Number(start_index))) {
      start_index = 0;
    }
    if (isNaN(x = Math.round(x))) {
      x = 0;
    }
    if (isNaN(y = Math.round(y))) {
      y = 0;
    }
    if (isNaN(frame = Number(frame))) {
      frame = 0;
    }
    start_index += frame;
    i = start_index % sheet.width;
    j = Math.floor(start_index / sheet.width);
    source = sheet.source;
    image = sheet.image;
    if ((source instanceof HTMLImageElement && source.complete || source instanceof SVGImageElement || source instanceof HTMLCanvasElement || (typeof createImageBitmap !== "undefined" && createImageBitmap !== null) && (image instanceof ImageBitmap || source instanceof ImageBitmap)) && !isNaN(i) && !isNaN(j) && (width = Number(sheet.sprite_width)) && (height = Number(sheet.sprite_height))) {
      return context.drawImage(((typeof createImageBitmap !== "undefined" && createImageBitmap !== null) && image instanceof ImageBitmap ? image : source), i * width, j * height, width, height, x, y, width, height);
    }
  };

  Sprite = function(sheet, index, length) {
    if (length == null) {
      length = 1;
    }
    if (!(sheet instanceof Sheet)) {
      sheet = null;
    }
    if (isNaN(index = Number(index))) {
      index = 0;
    }
    if (isNaN(length = Number(length)) || length <= 0) {
      length = 1;
    }
    this.draw = drawSprite.bind(null, sheet, index);
    this.height = sheet ? sheet.sprite_height : 0;
    this.index = index;
    this.frames = length;
    this.sheet = sheet;
    this.width = sheet ? sheet.sprite_width : 0;
    return Object.freeze(this);
  };

  Sprite.prototype = {
    draw: function() {}
  };

  Object.freeze(Sprite.prototype);

  Sheet = function(source, sprite_width, sprite_height) {
    var image, source_height, source_width;
    if (!(source instanceof HTMLImageElement || source instanceof SVGImageElement || source instanceof HTMLCanvasElement || (typeof createImageBitmap !== "undefined" && createImageBitmap !== null) && source instanceof ImageBitmap)) {
      source = null;
    }
    if (isNaN(sprite_width = Number(sprite_width))) {
      sprite_width = 0;
    }
    if (isNaN(sprite_height = Number(sprite_height))) {
      sprite_height = 0;
    }
    if (!((source != null) && !isNaN(source_width = Number(source.naturalWidth != null ? source.naturalWidth : source.width)))) {
      source_width = 0;
    }
    if (!((source != null) && !isNaN(source_height = Number(source.naturalHeight != null ? source.naturalHeight : source.height)))) {
      source_height = 0;
    }
    this.height = Math.floor(source_height / sprite_height);
    this.source = source;
    this.sprite_height = sprite_height;
    this.sprite_width = sprite_width;
    this.width = Math.floor(source_width / sprite_width);
    this.size = this.width * this.height;
    image = null;
    Object.defineProperty(this, "image", {
      get: function() {
        return image;
      }
    });
    if (typeof createImageBitmap !== "undefined" && createImageBitmap !== null) {
      createImageBitmap(source).then(function(img) {
        return image = img;
      });
    }
    return Object.freeze(this);
  };

  Sheet.prototype = {
    drawIndex: function(context, index, x, y) {
      return drawSprite(this, index, context, x, y);
    },
    getSprite: function(index, length) {
      if (length == null) {
        length = 1;
      }
      return new Sprite(this, index, length);
    }
  };

  Object.freeze(Sheet.prototype);

  Sheet.draw = function(context, sprite, x, y, frame) {
    if (frame == null) {
      frame = 0;
    }
    if (sprite instanceof Sprite) {
      return sprite.draw(context, x, y, frame);
    }
  };

  Sheet.drawSheetAtIndex = function(context, sheet, index, x, y) {
    if (sheet instanceof Sheet) {
      return sheet.drawIndex(context, index, x, y);
    }
  };

  Sheet.Sprite = Object.freeze(Sprite);

  window.Sheet = Object.freeze(Sheet);

}).call(this);
// Generated by CoffeeScript 1.10.0
(function() {
  var Tilemap, Tileset, collision_constants, decode64;

  decode64 = function(base64) {
    var code, data, i, j, len, n, placeholders;
    code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/-_";
    for (n = j = 0, len = code.length; j < len; n = ++j) {
      i = code[n];
      values[n] = i;
    }
    if ((base64 = String(base64)).length % 4) {
      return;
    }
    placeholders = (base64[base64.length - 2] === "=") + (base64[base64.length - 1] === "=");
    data = typeof Uint8Array !== "undefined" && Uint8Array !== null ? new Uint8Array(3 * base64.length / 4 - placeholders) : new Array(3 * base64.length / 4 - placeholders);
    i = 0;
    while (i < base64.length / 4) {
      n = values[base64[4 * i]] << 18 | values[base64[4 * i + 1]] << 12 | values[base64[4 * i + 2]] << 6 | values[base64[4 * i + 3]];
      data[3 * i] = n >> 16 & 0xFF;
      data[3 * i + 1] = n >> 8 & 0xFF;
      data[3 * i + 2] = n & 0xFF;
      i++;
    }
    return data;
  };

  Tilemap = function(tileset, context, map, tiles_wide, x, y, origin_x, origin_y) {
    var tiles_tall;
    if (!(tileset instanceof Tileset)) {
      tileset = null;
    }
    if (!(context instanceof CanvasRenderingContext2D)) {
      context = null;
    }
    map = decode64(map);
    if (isNaN(tiles_wide = Math.ceil(tiles_wide))) {
      tiles_wide = 0;
    }
    tiles_tall = Math.ceil(map.length / tiles_wide);
    if (isNaN(origin_x = Math.round(origin_x))) {
      origin_x = 0;
    }
    if (isNaN(origin_y = Math.round(origin_y))) {
      origin_y = 0;
    }
    if (x === Tilemap.CENTER && (context != null) && (tileset != null)) {
      x = Math.floor((context.canvas.width - tileset.tile_width * tiles_wide) / 2) - origin_x;
    }
    if (isNaN(x = Math.round(x))) {
      x = 0;
    }
    if (y === Tilemap.CENTER && (context != null) && (tileset != null)) {
      y = Math.floor((context.canvas.height - tileset.tile_height * tiles_tall) / 2) - origin_y;
    }
    if (isNaN(y = Math.round(y))) {
      y = 0;
    }
    this.context = context;
    this.map = map;
    if (tileset) {
      this.tile_height = tileset.tile_height;
    }
    if (tileset) {
      this.tile_width = tileset.tile_width;
    }
    this.tiles_tall = tiles_tall;
    this.tiles_wide = tiles_wide;
    this.tileset = tileset;
    Object.defineProperties(this, {
      origin_x: {
        get: function() {
          return origin_x;
        },
        set: function(n) {
          if (!isNaN(n = Math.round(n))) {
            return origin_x = n;
          }
        }
      },
      origin_y: {
        get: function() {
          return origin_y;
        },
        set: function(n) {
          if (!isNaN(n = Math.round(n))) {
            return origin_y = n;
          }
        }
      },
      x: {
        get: function() {
          return x;
        },
        set: function(n) {
          if (!isNaN(n = Math.round(n))) {
            return x = n;
          }
        }
      },
      y: {
        get: function() {
          return y;
        },
        set: function(n) {
          if (!isNaN(n = Math.round(n))) {
            return y = n;
          }
        }
      }
    });
    return Object.freeze(this);
  };

  Tilemap.prototype = {
    collides: function(sx, sy) {
      var collision, x, y;
      if (!(this.tileset instanceof Tileset && !(isNaN(sx = Number(sx)) || isNaN(sy = Number(sy))))) {
        return 0x0;
      }
      x = isNaN(this.x) ? sx : sx - this.x;
      y = isNaN(this.y) ? sy : sy - this.y;
      if (x < 0 || x >= this.tile_width * this.tiles_wide || y < 0 || y >= this.tile_height * this.tiles_tall) {
        return 0x0;
      }
      collision = this.tileset.getCollision(this.map[Math.floor(x / this.tile_width) + Math.floor(y / this.tile_height) * this.tiles_wide]);
      return collision & 1 * (1 + x % tile_width <= this.tile_width / 2) * (1 + 3 * (y % this.tile_height <= this.tile_height / 2));
    },
    draw: function() {
      var i, j, ref;
      if (!(this.context instanceof CanvasRenderingContext2D && this.tileset instanceof Tileset && !(isNaN(this.x) || isNaN(this.y) || isNaN(this.origin_x) || isNaN(this.origin_y)) && Number(this.tile_width) && Number(this.tile_height) && Number(this.tiles_wide) && typeof this.map === "object")) {
        return;
      }
      for (i = j = 0, ref = this.map.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        this.tileset.draw(this.context, this.map[i], Number(this.x) - Number(this.origin_x) + (i % this.tiles_wide) * this.tile_width, Number(this.y) - Number(this.origin_y) + Math.floor(i / this.tiles_wide) * this.tiles_height);
      }
    },
    getCollisionEdge: function(edge, sx, sy) {
      var at, collision, corner, i, ix, iy, x, y;
      if (!((edge === Tilemap.BOTTOM_EDGE || edge === Tilemap.LEFT_EDGE || edge === Tilemap.RIGHT_EDGE || edge === Tilemap.TOP_EDGE) && isNaN(sx = Number(sx)) && isNaN(sy = Number(sy)))) {
        return;
      }
      at = Tileset.collisions;
      x = Math.round(isNaN(this.x) ? sx : sx - this.x);
      y = Math.round(isNaN(this.y) ? sy : sy - this.y);
      ix = Math.floor(x / this.tile_width);
      iy = Math.floor(y / this.tile_height);
      i = ix + iy * this.tiles_wide;
      if (x % (this.tile_width / 2) === 0 || y % (this.tile_height / 2) === 0 || x < 0 || x >= this.tile_width * this.tiles_wide || y < 0 || y >= this.tile_height * this.tiles_tall) {
        corner = collision = at.NO_COLLISION;
      } else {
        collision = this.tileset.getCollision(this.map[i]);
        corner = this.collides(sx, sy);
      }
      if (!corner) {
        return (edge === Tilemap.LEFT_EDGE || edge === Tilemap.RIGHT_EDGE ? sx : sy);
      }
      switch (edge) {
        case Tilemap.BOTTOM_EDGE:
          return (corner === at.TOPLEFT && collision & at.BOTTOMLEFT || corner === at.TOPRIGHT && collision & at.BOTTOMRIGHT ? iy * this.tile_height + this.tile_height + this.y : iy * this.tile_height + this.tile_height / 2 + this.y);
        case Tilemap.LEFT_EDGE:
          return (corner === at.TOPRIGHT && collision & at.TOPLEFT || corner === at.BOTTOMRIGHT && collision & at.BOTTOMLEFT ? ix * this.tile_width + this.x : ix * this.tile_width + this.tile_width / 2 + this.x);
        case Tilemap.RIGHT_EDGE:
          return (corner === at.TOPLEFT && collision & at.TOPRIGHT || corner === at.BOTTOMLEFT && collision & at.BOTTOMRIGHT ? ix * this.tile_width + this.tile_width + this.x : ix * this.tile_width + this.tile_width / 2 + this.x);
        case Tilemap.TOP_EDGE:
          return (corner === at.BOTTOMLEFT && collision & at.TOPLEFT || corner === at.BOTTOMRIGHT && collision & at.TOPRIGHT ? iy * this.tile_height + this.y : iy * this.tile_height + this.tile_height / 2 + this.y);
      }
    }
  };

  Object.freeze(Tilemap.prototype);

  Object.defineProperties(Tilemap, {
    BOTTOM_EDGE: {
      value: typeof Symbol !== "undefined" && Symbol !== null ? Symbol("bottom") : Object.freeze(Object.create(null))
    },
    CENTER: {
      value: typeof Symbol !== "undefined" && Symbol !== null ? Symbol("center") : Object.freeze(Object.create(null))
    },
    LEFT_EDGE: {
      value: typeof Symbol !== "undefined" && Symbol !== null ? Symbol("left") : Object.freeze(Object.create(null))
    },
    RIGHT_EDGE: {
      value: typeof Symbol !== "undefined" && Symbol !== null ? Symbol("right") : Object.freeze(Object.create(null))
    },
    TOP_EDGE: {
      value: typeof Symbol !== "undefined" && Symbol !== null ? Symbol("top") : Object.freeze(Object.create(null))
    }
  });

  Tileset = function(sheet, tile_width, tile_height, collisions, draw) {
    if (isNaN(tile_width = Number(tile_width))) {
      tile_width = 0;
    }
    if (isNaN(tile_height = Number(tile_height))) {
      tile_height = 0;
    }
    if (!(typeof draw === "function" || draw instanceof Function)) {
      draw = null;
    }
    this.collisions = decode64(collisions);
    this.drawFunction = draw;
    this.sheet = sheet;
    this.tile_height = tile_height;
    this.tile_width = tile_width;
    return Object.freeze(this);
  };

  Tileset.prototype = {
    draw: function(context, index, x, y) {
      if (typeof this.drawFunction === "function" || this.drawFunction instanceof Function) {
        return this.drawFunction(context, this.sheet, index, x, y);
      }
    },
    getMap: function(context, map, tiles_wide, x, y, origin_x, origin_y) {
      return new Tilemap(this, context, map, tiles_wide, x, y, origin_x, origin_y);
    },
    getCollision: function(index) {
      if (isNaN(index)) {
        return 0;
      } else {
        return (this.collisions[Math.floor(index / 2)] >> 4 * ((index + 1) % 2)) & 0xF;
      }
    }
  };

  Object.freeze(Tileset.prototype);

  collision_constants = Object.create(Object.prototype, {
    EMPTY: {
      value: 0x0,
      enumerated: true
    },
    NO_COLLISION: {
      value: 0
    },
    SECTOR_00: {
      value: 0x1,
      enumerated: true
    },
    SECTOR_01: {
      value: 0x2,
      enumerated: true
    },
    SECTOR_02: {
      value: 0x4,
      enumerated: true
    },
    SECTOR_03: {
      value: 0x8,
      enumerated: true
    },
    SECTOR_04: {
      value: 0x10,
      enumerated: true
    },
    SECTOR_05: {
      value: 0x20,
      enumerated: true
    },
    SECTOR_06: {
      value: 0x40,
      enumerated: true
    },
    SECTOR_07: {
      value: 0x80,
      enumerated: true
    },
    SECTOR_08: {
      value: 0x100,
      enumerated: true
    },
    SECTOR_09: {
      value: 0x200,
      enumerated: true
    },
    SECTOR_10: {
      value: 0x400,
      enumerated: true
    },
    SECTOR_11: {
      value: 0x800,
      enumerated: true
    },
    SECTOR_12: {
      value: 0x1000,
      enumerated: true
    },
    SECTOR_13: {
      value: 0x2000,
      enumerated: true
    },
    SECTOR_14: {
      value: 0x4000,
      enumerated: true
    },
    SECTOR_15: {
      value: 0x8000,
      enumerated: true
    },
    SECTOR_16: {
      value: 0x10000,
      enumerated: true
    },
    SECTOR_17: {
      value: 0x20000,
      enumerated: true
    },
    SECTOR_18: {
      value: 0x40000,
      enumerated: true
    },
    SECTOR_19: {
      value: 0x80000,
      enumerated: true
    },
    SECTOR_20: {
      value: 0x100000,
      enumerated: true
    },
    SECTOR_21: {
      value: 0x200000,
      enumerated: true
    },
    SECTOR_22: {
      value: 0x400000,
      enumerated: true
    },
    SECTOR_23: {
      value: 0x800000,
      enumerated: true
    },
    SECTOR_24: {
      value: 0x1000000,
      enumerated: true
    },
    SECTOR_25: {
      value: 0x2000000,
      enumerated: true
    },
    SECTOR_26: {
      value: 0x4000000,
      enumerated: true
    },
    SECTOR_27: {
      value: 0x8000000,
      enumerated: true
    },
    SECTOR_28: {
      value: 0x10000000,
      enumerated: true
    },
    SECTOR_29: {
      value: 0x20000000,
      enumerated: true
    },
    SECTOR_30: {
      value: 0x40000000,
      enumerated: true
    },
    SECTOR_31: {
      value: 0x80000000,
      enumerated: true
    },
    TOPLEFT: {
      value: 1
    },
    TOPRIGHT: {
      value: 2
    },
    BOTTOMLEFT: {
      value: 4
    },
    BOTTOMRIGHT: {
      value: 8
    }
  });

  Object.defineProperty(Tileset, "collisions", {
    value: Object.freeze(collision_constants)
  });

  Tileset.Map = Object.freeze(Tilemap);

  window.Tileset = Object.freeze(Tileset);

}).call(this);
